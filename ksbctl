#!/bin/ksh -u

# command to manage tyk instances in distinct namespaces

PATH=/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin:$PATH

# Dependencies
#  minikube to run a local kubernetes
#  ksh to support arrays. the Mac version of bash doesn't
#  envsubst to populate environment variables into the YAML
#  mongosh to retrieve things from mongodb (what?)
#  redis-cli to retrieve admin credentials

# todo: 
#		(done) be able to set the version used
#			(done) create index of versions that can be used
#			(done) use envsubst to create sandboxes of different versions
#			Save versions in label and display them in the info/list commands
#			Set versions for mongo/redis and postgresql too
#		(done) test for command dependencies
#			(done) minikube
#				(done) allow creation of cluster if not present
#			(done) envsubst mongo shell redis-cli
#		test on other platforms
#			windows
#			MacOS
#				M1
#		(done) Better checking of pod startup.
#			(done) Warn if pods in 'Pending' and exit
#		(done) expose redis and mongo ports
#		retrieve credentials from redis
#			display creds when asked
#			autoload APIs
#		deploy with MDCB
#		deploy with postgresql
#		create way to deploy plugins
#			bundle server
#			golang
#     share plugin folders with sbctl
#			python/lua
#		Convenience commands
#			logs
#			shell
#			performance stats
#			publish APIs
#			shell into the container running the cluster

alias kubectl="minikube kubectl -- "
SCRIPTNAME=$0
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:$PATH
SCRIPTDIR=$(
	cd "$(dirname $SCRIPTNAME)"
	echo $PWD
)
VERSIONFILE="$SCRIPTDIR/tyk-versions.list"
YAMLDIR="$SCRIPTDIR/YAML"
NAMESPACE_SELECTOR="purpose=support"
NAMESPACE=''
imageVersion=''

# load env variables
ENVFILE=~/.tyk-sandbox
if [[ -f $ENVFILE ]]; then
	. $ENVFILE
else
	SBX_LICENSE=""
	SBX_USER=""
	SBX_PASSWORD=""
fi

function checkMinikubeInstalled {
	if ! which minikube >/dev/null
	then
		echo "[FATAL]Command 'minikube' not found. Cannot continue"
		exit 1
	fi
}

function checkEnvsubstInstalled {
	if ! which envsubst >/dev/null
	then
		echo "[FATAL]Command 'envsubst' not found. Cannot continue"
		exit 1
	fi
}

function checkRedisCliInstalled {
	if ! which redis-cli >/dev/null
	then
		echo "[FATAL]Command 'redis-cli' not found. Cannot continue"
		exit 1
	fi
}

function checkMongoShellInstalled {
	if ! which mongo >/dev/null
	then
		if which mongosh /dev/null
		then
			alias mongo=mongosh
		else
			echo "[FATAL]Mongo shell 'mongo' or 'mongosh' not installed. Cannot continue"
			exit 1
		fi
	fi
}

# check for command dependencies
checkMinikubeInstalled
checkRedisCliInstalled
checkMinikubeInstalled

# create or start minikube if it's not already running
function startMinikube {
	if ! minikube status > /dev/null 2>&1 ;then
		echo "[INFO]Starting minikube"
		minikube start --driver docker --cpus max --memory max
	fi
	minikubeIP=$(minikube ip)
}

function getPodName {
	kubectl get pods --no-headers=true -n $NAMESPACE | awk '/^'$1'/ {print $1}'
}

function help {
	typeset name
	name=$(basename $SCRIPTNAME)
	echo "[USAGE]:"
	echo "$name create -v <tyk version> -t <intance tag>"
	echo "      Create a tyk instance the name space given as a tag"
	echo "$name delete <instance tag>"
	echo "      Delete the namespace given as a tag and all resources in it"
	echo "$name list"
	echo "      List all namespaces"
	echo "$name info <instance tag>"
	echo "      Print info on the particular instance"
}

# wait for a pod to start
function waitPodReady {
	typeset podname
	podname=$(getPodName $1)
	echo -n "[INFO]Waiting for $NAMESPACE:$podname to start."
	while [[ $( kubectl get pods --no-headers=true -n $NAMESPACE "$podname" | awk -F '[ /]+' '{print $2}' ) -ne 1 ]]; do
		echo -n .
		sleep 5
		if kubectl logs -n $NAMESPACE "$podname" 2>&1 | grep -q 'trying and failing to pull image'; then
			echo; echo "[FATAL]Unable to pull image for '$podname'"
			exit 1
		fi
		# Pending pods mean there aren't enough resources. Warn and exit
		if kubectl get pods --no-headers=true -n $NAMESPACE "$podname" | grep -qi 'pending'; then
			# give it some time to find a place for the pod
			sleep 5
			if kubectl get pods --no-headers=true -n $NAMESPACE "$podname" | grep -qi 'pending'; then
				echo; echo "[FATAL]Not enough resources in the cluster to run $podname"
				exit 1
			fi
		fi
	done
	echo " done"
}

function getMongoPort {
	typeset mongoService
	mongoService=$(kubectl get svc -n $NAMESPACE | awk '$1 ~ /mongo/ {print $1}' | head -1)
	kubectl get svc -n $NAMESPACE $mongoService --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getRedisPort {
	typeset redisService
	redisService=$(kubectl get svc -n $NAMESPACE | awk '$1 ~ /redis/ {print $1}' | head -1)
	kubectl get svc -n $NAMESPACE $redisService --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getDashboardPort {
	typeset dashboardService
	dashboardService=$(kubectl get svc -n $NAMESPACE | awk '$1 ~ /dashboard/ {print $1}' | head -1)
	kubectl get svc -n $NAMESPACE $dashboardService --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getGatewayPort {
	typeset gatewayService
	gatewayService=$(kubectl get svc -n $NAMESPACE | awk '$1 ~ /gateway/ {print $1}' | head -1)
	kubectl get svc -n $NAMESPACE $gatewayService --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function reportSanboxInfo {
	typeset description
	typeset label
	for label in $(kubectl get namespaces --show-labels --selector=$NAMESPACE_SELECTOR | awk '/^tyk / {print $NF}' | xargs -d,); do
		if echo $label | grep -q description=; then
			description=$(echo $label | cut -d= -f2)
			echo "$NAMESPACE.description: $description"
		fi
	done
	echo "$NAMESPACE.dashboard: http://$minikubeIP:$(getDashboardPort)/"
	echo "$NAMESPACE.gateway:   http://$minikubeIP:$(getGatewayPort)/"
	echo "$NAMESPACE.mongo:     mongo --quiet --host $minikubeIP --port $(getMongoPort)"
	echo "$NAMESPACE.redis:     redis-cli -h $minikubeIP -p $(getRedisPort)"
}

function createNamespace {
	if ! kubectl get namespaces | grep -wq $NAMESPACE; then
		kubectl create ns $NAMESPACE
		kubectl label ns $NAMESPACE $NAMESPACE_SELECTOR
		echo "[INFO]Created namespace '$NAMESPACE'"
	fi
}

# process the YAML with envsubst to substitute environment variables into them
function applyYAML {
	typeset YAML
	typeset YAMLfile
	YAML=""
	for YAMLfile in $*; do
		YAMLfile=$(basename $YAMLfile)
		if [[ -f $YAMLDIR/$YAMLfile ]]; then
			cat $YAMLDIR/$YAMLfile | envsubst | tee -a /tmp/images | kubectl apply -n $NAMESPACE -f -
		fi
	done
}

function OldapplyYAML {
	typeset YAML
	typeset YAMLfile
	YAML=""
	for YAMLfile in $*; do
		YAMLfile=$(basename $YAMLfile)
		if [[ -f $YAMLDIR/$YAMLfile ]]; then
			YAML="$YAML -f $YAMLDIR/$YAMLfile"
		fi
	done
	kubectl apply -n $NAMESPACE $YAML
}

function licenseDashboard {
	if [[ -n $SBX_LICENSE ]]; then
		echo "[INFO]Licenseing the dashboard"
		curl -s -d "license=$SBX_LICENSE" http://$minikubeIP:$(getDashboardPort)/license > /dev/null
	fi
}

function addDashboardUser {
	if [[ -n $SBX_USER && -n $SBX_PASSWORD ]]; then
		SBX_CLEAR_PASSWORD=$(echo $SBX_PASSWORD | base64 -d)
		# this bootstrap method is reliable for versions 2.9.x - 3.2.x (won't work on 2.8.x or earlier)
		echo "[INFO]Adding admin account $SBX_USER"
		curl -s -d "email_address=$SBX_USER&first_name=Tyk&last_name=Admin&password=$SBX_CLEAR_PASSWORD&confirm_password=$SBX_CLEAR_PASSWORD" http://$minikubeIP:$(getDashboardPort)/bootstrap > /dev/null
	fi
}

function addAPIs {
	if [[ -n $SBX_USER && -n $SBX_PASSWORD ]]; then
		# only attempt if we've got a username and password because we need a auth ID
		:
	fi
}

function listPods {
	kubectl get pods -n $NAMESPACE
}

# isolated to keep IFS from leaking
function loadVersions {
	typeset line
	typeset IFS
	typeset gwVers
	typeset dshbVers
	typeset pumpVers
	typeset TIBvers
	typeset syncVers
	typeset version
	line=$1
	IFS=,
	echo "$line" | read version gwVers dshbVers pumpVers TIBvers syncVers
	export KSBX_GATE_VERS="v${gwVers%%-*}"
	export KSBX_DASH_VERS="v${dshbVers%%-*}"
	export KSBX_PUMP_VERS="v${pumpVers%%-*}"
}

# Process commands and take actions
# make sure minikube is running and populate minikubeIP, the minikubeIP address it uses

if [[ $# -gt 0 ]]; then
	startMinikube
	case $1 in 
		create)
			shift
			while getopts v:t: arg; do
				case $arg in
					t)
						NAMESPACE=$(echo $OPTARG | sed 's/ /-/g')
						;;
					v)
						imageVersion=$OPTARG
						;;
					:)
						echo "[FATAL]Option -$OPTARG requires an arguement."
						exit 1
						;;
					\?)
						echo "[FATAL]Invalid option: -$OPTARG"
						exit 1
						;;
				esac
			done
			if [[ -z $NAMESPACE || -z $imageVersion ]]; then
				echo "[FATAL]Both -v and -t must be set"
				help
				exit 1
			fi
			KSBX_NS=$NAMESPACE
			export KSBX_NS
			if egrep -q "^$imageVersion," $VERSIONFILE; then
				loadVersions $(grep -e "^$imageVersion," $VERSIONFILE | head -1)
				echo "[INFO]Using Gateway $KSBX_GATE_VERS, Dashboard $KSBX_DASH_VERS, Pump $KSBX_PUMP_VERS"
			else
				echo "[FATAL]Unable to find '$imageVersion' in '$VERSIONFILE'"
				exit 1
			fi
			createNamespace
			echo "[INFO]Starting redis and mongo"
			applyYAML mongo.yaml redis.yaml # grpc-plugin.yaml
			waitPodReady redis
			waitPodReady mongo
			echo "[INFO]Starting dashboard, pump and gateway"
			applyYAML tyk-dashboard.yaml tyk-gateway.yaml tyk-dashboard-svc.yaml tyk-gateway-svc.yaml tyk-pump.yaml
			waitPodReady tyk-dashboard
			licenseDashboard
			addDashboardUser
			listPods
			reportSanboxInfo 
			;;
		delete | rm | del)
			shift
			if [[ $# -lt 1 ]]; then
				echo "[FATAL]Must provide namespace"
				exit 1
			fi
			kubectl delete namespace $*
			;;
		help)
			help
			exit 0
			;;
		list)
			kubectl get namespaces --selector=$NAMESPACE_SELECTOR
			;;
		pods)
			shift
			if [[ $# -lt 1 ]]; then
				echo "[FATAL]Must provide namespace"
				exit 1
			fi
			NAMESPACE=$1
			listPods
			;;
		info)
			shift
			if [[ $# -lt 1 ]]; then
				echo "[FATAL]Must provide namespace"
				exit 1
			fi
			for NAMESPACE in $*; do
				echo "[INFO]$NAMESPACE"
				if kubectl get namespaces --selector=$NAMESPACE_SELECTOR 2>&1 | grep -q $NAMESPACE; then
					listPods
					reportSanboxInfo
				else
					echo "[WARN]Namespace '$NAMESPACE' not found"
				fi
			done
			;;
		*)
			echo "[FATAL]$1 not implemented"
			;;
	esac
else
	help
fi
