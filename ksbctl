#!/bin/ksh -u

# command to manage tyk instances in distinct namespaces

PATH=/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin:$PATH

# Dependencies
#  minikube to run a local kubernetes
#  ksh to support arrays. the Mac version of bash doesn't
#  envsubst to populate environment variables into the YAML
#  mongosh to retrieve things from mongodb (what?)
#  redis-cli to retrieve admin credentials

# todo: 
#		(done) Use volumes to hold persistent data
#			(done) Mongodb
#				https://github.com/kubernetes/minikube/issues/7511#issuecomment-1022222474
#				add to /etc/tmpfiles.d/tmp.conf
#  				-D /tmp 1777 root root -
#					+d /tmp 1777 root root 1s
#					+x /tmp/hostpath-provisioner/*
#			(done) Redis
#		(done) be able to set the version used
#			(done) create index of versions that can be used
#			(done) use envsubst to create sandboxes of different versions
#			Save versions in label and display them in the info/list commands
#			Set versions for mdcb, mongo/redis and postgresql too
#			Allow commandline override of versions of all components
#		(done) test for command dependencies
#			(done) minikube
#				(done) allow creation of cluster if not present
#			(done) envsubst mongo shell redis-cli
#		test on other platforms
#			windows
#			MacOS
#				M1
#		(done) Better checking of pod startup.
#			(done) Warn if pods in 'Pending' and exit
#		(done) expose redis and mongo ports
#		(done) retrieve credentials from redis
#			(done) display admin creds when asked
#			(done) autoload APIs
#		deploy with MDCB
#		deploy with postgresql
#		create way to deploy plugins
#			bundle server
#			golang
#     share plugin folders with sbctl
#			python/lua
#		Convenience commands
#			(done) logs
#			(done) shell
#			performance stats
#			(done) publish APIs
#			shell into the container running the cluster

alias kubectl="minikube kubectl -- "
SCRIPTNAME=$0
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:$PATH
SCRIPTDIR=$(
	cd "$(dirname $SCRIPTNAME)"
	echo $PWD
)
VERSIONFILE="$SCRIPTDIR/tyk-versions.list"
YAMLDIR="$SCRIPTDIR/YAML"
NAMESPACE_SELECTOR="purpose=support"
NAMESPACE=''
DATABASE=mongo
imageVersion=''
KSBX_GATE_VERS=''
KSBX_DASH_VERS=''
KSBX_PUMP_VERS=''
KSBX_MDCB_VERS=''
KSBX_NS=''
MONGOSHELL=''
export KSBX_PGPASSWORD=password		# default postgres password
export KSBX_PGUSER=postgresx				# default postgres username
export KSBX_PGDB=tyk_analytics		# default postgres database

# load env variables
ENVFILE=~/.tyk-sandbox
if [[ -f $ENVFILE ]]; then
	. $ENVFILE
else
	SBX_LICENSE=""
	SBX_USER=""
	SBX_PASSWORD=""
fi

function help {
	typeset name
	name=$(basename $SCRIPTNAME)
	echo "[USAGE]:"
	echo "$name create -v <tyk version> -t <namespace> -p"
	echo "      Create a tyk instance the name space given as a tag"
	echo "      -p deploy with postgres not mongo"
	echo "$name delete <namespace>"
	echo "      Delete the namespace given as a tag and all resources in it"
	echo "$name list"
	echo "      List all namespaces"
	echo "$name logs <namespace> <podname>"
	echo "      Tail the logs of the named pod"
	echo "$name info <namespace>"
	echo "      Print info on the particular instance"
	echo "$name shell <namespace> <pod>"
	echo "      Start an interactive shell in the pod."
	echo "      The pod name can be a substring of the actual name"
	echo "      eg. $name shell ns1 dashboard"
}

function checkCommandInstalled {
	typeset cmd
	echo "[INFO]Checking for these commands: $*"
	for cmd in $*; do
		if ! which $cmd >/dev/null; then
			echo "[FATAL]Command '$cmd' not found. Cannot continue"
			exit 1
		fi
	done
}

function checkMongoShellInstalled {
	if [[ -z $MONGOSHELL ]]; then
		if ! which mongo >/dev/null; then
			if which mongosh > /dev/null; then
				alias mongo=mongosh
				MONGOSHELL=mongosh
			else
				echo "[FATAL]Mongo shell 'mongo' or 'mongosh' not installed. Cannot continue"
				exit 1
			fi
		else
				MONGOSHELL=mongo
		fi
	fi
}


# create or start minikube if it's not already running
function startMinikube {
	if ! minikube status > /dev/null 2>&1 ;then
		echo "[INFO]Starting minikube"
		# check for command dependencies
		checkCommandInstalled minikube redis-cli jq envsubst psql
		minikube start --driver docker --cpus max --memory max
		minikube cp "$SCRIPTDIR/etc/tmp.conf" /etc/tmpfiles.d/ --user root
		# give it a few seconds to settle down
		sleep 10
	fi
	minikubeIP=$(minikube ip)
}

function getPodName {
	kubectl get pods --no-headers=true -n $NAMESPACE | awk '/^'$1'/ {print $1}' | head -1
}

# wait for a deployment to be ready
function waitDeploymentReady {
	typeset deploymentName
	deploymentName=$1
	if [[ -n $deploymentName ]]; then
		if kubectl get deployment --no-headers=true -n $NAMESPACE $deploymentName > /dev/null 2>&1; then
			echo -n "[INFO]Waiting for deployment $NAMESPACE:$deploymentName to be ready."
			while [[ $( kubectl get deployment --no-headers=true -n $NAMESPACE $deploymentName | awk -F '[ /]+' '{print $2 - $3}' ) -ne 0 ]]; do
				echo -n .
				sleep 5
			done
		else
			echo "[FATAL]Cannot find a deployment matching '$1'"
			exit 1
		fi
	fi
	echo " done"
}

# wait for a pod to start
function waitPodReady {
	typeset podName
	podName=$(getPodName $1)
	if [[ -n $podName ]]; then

		echo -n "[INFO]Waiting for pod $NAMESPACE:$podName to be ready."
		while [[ $( kubectl get pods --no-headers=true -n $NAMESPACE "$podName" | awk -F '[ /]+' '{print $2}' ) -ne 1 ]]; do
			echo -n .
			sleep 5
			if kubectl logs -n $NAMESPACE "$podName" 2>&1 | grep -q 'trying and failing to pull image'; then
				echo; echo "[FATAL]Unable to pull image for '$podName'"
				exit 1
			fi
			# Pending pods mean there aren't enough resources. Warn and exit
			if kubectl get pods --no-headers=true -n $NAMESPACE "$podName" | grep -qi 'pending'; then
				# give it some time to find a place for the pod
				sleep 5
				if kubectl get pods --no-headers=true -n $NAMESPACE "$podName" | grep -qi 'pending'; then
					echo; echo "[FATAL]Not enough resources in the cluster to run $podName"
					exit 1
				fi
			fi
		done
	else
		echo "[FATAL]Cannot find a pod matching '$1'"
		exit 1
	fi
	echo " done"
}

function getAdminUserKey {
	typeset redisPort
	typeset redisKey
	redisPort=$(getControlRedisPort)
	for redisKey in $(redis-cli -h $minikubeIP -p $redisPort --scan --pattern 'tyk-admin-api-*'); do
		if [[ $(redis-cli -h $minikubeIP -p $redisPort type $redisKey) == 'string' ]]; then
			if [[ "admin" == $(redis-cli -h $minikubeIP -p $redisPort get $redisKey | jq -r .UserData.user_permissions.IsAdmin) ]]; then
				redis-cli -h $minikubeIP -p $redisPort get $redisKey | jq -r .UserData.access_key 
				return 0
			fi
		fi
	done
}

function getOrgID {
	typeset redisPort
	typeset redisKey
	redisPort=$(getControlRedisPort)
	for redisKey in $(redis-cli -h $minikubeIP -p $redisPort --scan --pattern 'tyk-admin-api-*'); do
		if [[ $(redis-cli -h $minikubeIP -p $redisPort type $redisKey) == 'string' ]]; then
			if [[ "admin" == $(redis-cli -h $minikubeIP -p $redisPort get $redisKey | jq -r .UserData.user_permissions.IsAdmin) ]]; then
				redis-cli -h $minikubeIP -p $redisPort get $redisKey | jq -r .UserData.org_id
				return 0
			fi
		fi
	done
}

function getPostgresPort {
	typeset postgresService
	postgresService=$(kubectl get svc -n $NAMESPACE --no-headers=true | awk '$1 ~ /postgres/ {print $1}' | head -1)
	kubectl get svc -n $NAMESPACE postgres-db --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getMongoPort {
	typeset mongoService
	mongoService=$(kubectl get svc -n $NAMESPACE --no-headers=true | awk '$1 ~ /mongo/ {print $1}' | head -1)
	kubectl get svc -n $NAMESPACE mongo-db --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getEdgeRedisPort {
	kubectl get svc -n $NAMESPACE edge-redis --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getControlRedisPort {
	kubectl get svc -n $NAMESPACE control-redis --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getDashboardPort {
	kubectl get svc -n $NAMESPACE tyk-dashboard --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getEdgeGatewayPort {
	kubectl get svc -n $NAMESPACE edge-gateway --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getControlGatewayPort {
	kubectl get svc -n $NAMESPACE control-gateway --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function reportSanboxInfo {
	echo "$NAMESPACE.dashboard:         http://$minikubeIP:$(getDashboardPort)/"
	echo "$NAMESPACE.control-gateway:   http://$minikubeIP:$(getControlGatewayPort)/"
	if [[ $DATABASE == 'mongo' ]]; then
		checkMongoShellInstalled
		echo "$NAMESPACE.mongo:             $MONGOSHELL --quiet --host $minikubeIP --port $(getMongoPort)"
	fi
	if [[ $DATABASE == 'postgres' ]]; then
		echo "$NAMESPACE.postgres:          PGPASSWORD=$KSBX_PGPASSWORD psql --username=$KSBX_PGUSER --dbname=$KSBX_PGDB --host=$minikubeIP --port=$(getPostgresPort)"
	fi
	echo "$NAMESPACE.redis:             redis-cli -h $minikubeIP -p $(getControlRedisPort)"
	echo "$NAMESPACE.AdminKey:          $(getAdminUserKey)"
	echo "$NAMESPACE.OrgID:             $(getOrgID)"
}

function createNamespace {
	if ! namespaceExists $NAMESPACE; then
		kubectl create ns $NAMESPACE
		kubectl label ns $NAMESPACE $NAMESPACE_SELECTOR
		if [[ -n $KSBX_GATE_VERS ]]; then
			kubectl label ns $NAMESPACE TYK_GW=$KSBX_GATE_VERS
		fi
		if [[ -n $KSBX_DASH_VERS ]]; then
			kubectl label ns $NAMESPACE TYK_DB=$KSBX_DASH_VERS
		fi
		if [[ -n $KSBX_PUMP_VERS ]]; then
			kubectl label ns $NAMESPACE TYK_PMP=$KSBX_PUMP_VERS
		fi
		if [[ -n $KSBX_MDCB_VERS ]]; then
			kubectl label ns $NAMESPACE TYK_MDCB=$KSBX_MDCB_VERS
		fi
			kubectl label ns $NAMESPACE TYK_DATABASE=$DATABASE
		echo "[INFO]Created namespace '$NAMESPACE'"
	fi
}

function namespaceExists {
	kubectl get namespaces --no-headers=true | grep -wq $NAMESPACE
	return $?
}

# Process the YAML with envsubst to substitute environment variables into them
# All exported environment varables are available to envsubst but these are the main ones
# KSBX_GATE_VERS which has the gateway version. This is used to pull the gateway docker image
# KSBX_DASH_VERS which has the dashboard version. This is used to pull the dashboard docker image
# KSBX_PUMP_VERS which has the pump version. This is used to pull the pump docker image
# KSBX_MDCB_VERS which has the MDCB version. This is used to pull the MDCB docker image
# KSBX_NS which is the namespace for the pods etc.
function applyYAML {
	typeset YAML
	typeset YAMLfile
	YAML=""
	for YAMLfile in $*; do
		YAMLfile=$(basename $YAMLfile)
		if [[ -f $YAMLDIR/$YAMLfile ]]; then
			cat $YAMLDIR/$YAMLfile | envsubst | tee -a /tmp/images | kubectl apply -n $NAMESPACE -f -
		fi
	done
}

function OldapplyYAML {
	typeset YAML
	typeset YAMLfile
	YAML=""
	for YAMLfile in $*; do
		YAMLfile=$(basename $YAMLfile)
		if [[ -f $YAMLDIR/$YAMLfile ]]; then
			YAML="$YAML -f $YAMLDIR/$YAMLfile"
		fi
	done
	kubectl apply -n $NAMESPACE $YAML
}

function licenseDashboard {
	if [[ -n $SBX_LICENSE ]]; then
		echo "[INFO]Licenseing the dashboard"
		curl -s -d "license=$SBX_LICENSE" http://$minikubeIP:$(getDashboardPort)/license > /dev/null
	fi
}

function addDashboardUser {
	if [[ -n $SBX_USER && -n $SBX_PASSWORD ]]; then
		SBX_CLEAR_PASSWORD=$(echo $SBX_PASSWORD | base64 -d)
		# this bootstrap method is reliable for versions 2.9.x - 3.2.x (won't work on 2.8.x or earlier)
		echo "[INFO]Adding admin account $SBX_USER"
		curl -s -d "email_address=$SBX_USER&first_name=Tyk&last_name=Admin&password=$SBX_CLEAR_PASSWORD&confirm_password=$SBX_CLEAR_PASSWORD" http://$minikubeIP:$(getDashboardPort)/bootstrap > /dev/null
	fi
}

function addAPIs {
	if [[ -n $SBX_USER && -n $SBX_PASSWORD ]]; then
		# only attempt if we've got a username and password because we need a auth ID
		:
	fi
}

function listPods {
	kubectl get pods -n $NAMESPACE
}

function getDatabaseType {
	DATABASE=$(kubectl get namespace $NAMESPACE -o json | jq -r .metadata.labels.TYK_DATABASE)
}

# report the tyk versions saved in the namespace Labels when it was created
function showTykVersions {
	typeset label
	typeset value
	typeset report
	report=''
	for label in TYK_DB TYK_GW TYK_PMP TYK_MDCB; do
		value=$(kubectl get namespace -L $label $NAMESPACE -o json | jq -r .metadata.labels.$label)
		if [[ $value != 'null' ]]; then
			report="$report $label=$value"
		fi
	done
	echo $report
}

# isolated to keep IFS from leaking
function loadVersions {
	typeset line
	typeset IFS
	typeset gwVers
	typeset dshbVers
	typeset pumpVers
	typeset TIBvers
	typeset syncVers
	typeset version
	line=$1
	IFS=,
	echo "$line" | read version gwVers dshbVers pumpVers TIBvers syncVers
	export KSBX_GATE_VERS="v${gwVers%%-*}"
	export KSBX_DASH_VERS="v${dshbVers%%-*}"
	export KSBX_PUMP_VERS="v${pumpVers%%-*}"
}

function runShell {
	typeset podType
	typeset pod
	for podType in $*
	do
		echo "[INFO]Creating shell for $podType"
		for pod in $(kubectl get pods -n $NAMESPACE | awk '/'$podType'/ {print $1}')
		do
			# if ncurses-base isnt installed then TERM isn't recognised
			# I found it was installed in some images but not others
			echo "[INFO]Checking for ncurses-base in $pod"
			if ! kubectl exec $pod -n $NAMESPACE -- test -d /lib/terminfo >/dev/null 2>&1; then
				echo "[INFO]Installing ncurses-base to provide terminal types to the shell"
				kubectl exec $pod -n $NAMESPACE -- apt install ncurses-base -y > /dev/null 2>&1
			fi
			echo "[INFO]starting bash in $pod"
			echo "[INFO]kubectl exec $pod -n $NAMESPACE -it -- /bin/bash"
			kubectl exec $pod -n $NAMESPACE -it -- /bin/bash
		done
	done
}

function showLogs {
	typeset podType
	typeset pod
	podType=$1
	pod=$(kubectl get pods -n $NAMESPACE | awk '/'$podType'/ {print $1}' | head -1)
	kubectl logs -n $NAMESPACE $pod -f
}

# Sometimes PersistentVolumeClaim are left when the namespace is deleted.
# Tidy up any in state 'Released'
function tidyPVCs {
	typeset pvc
	for pvc in $(kubectl get pv --no-headers=true 2>/dev/null | awk '$5=="Released" {print $1}'); do
		echo "[INFO]kubectl delete pv $pvc"
		kubectl delete pv $pvc
	done
}

function createApiDefintion {
  # converts API definition format from the one given using 'export' on the dashboard to the one expected when importing via /api/apis
  typeset APIfile
  APIfile="$1"
  echo '  {'
  echo '    "api_model": {},'
  echo '    "api_definition":' $(<"$APIfile") ','
  echo '    "hook_references": [],'
  echo '    "is_site": false,'
  echo '    "sort_by": 0'
  echo '}'
}

function publishAPIs {
	typeset APIfile
	typeset adminKey
	typeset DashboardPort
	adminKey=$(getAdminUserKey)
	DashboardPort=$(getDashboardPort)
	for APIfile in "$@"; do
		echo "[INFO]Publishing API $APIfile"
		if grep -q api_definition "$APIfile"; then
			# deal with the files that are a copy and paste of the API JSON from the dashboard
			curl -s -X POST -H "Content-Type: application/json" -H "Authorization: $adminKey" http://$minikubeIP:$DashboardPort/api/apis -d@"$APIfile" > /dev/null
		else
			# deal with the files that are exported APIs from the dashboard
			APIfileName=$(mktemp /tmp/$(basename "$APIfile").XXXXXX)
			createApiDefintion "$APIfile" > $APIfileName
			curl -s -X POST -H "Content-Type: application/json" -H "Authorization: $adminKey" http://$minikubeIP:$DashboardPort/api/apis -d@"$APIfileName" > /dev/null
			\rm $APIfileName
		fi
	done
}

# Process commands and take actions
if [[ $# -gt 0 ]]; then
	# make sure minikube is running and populate minikubeIP, the minikubeIP address it uses
	startMinikube
	case $1 in 
		create)
			shift
			while getopts v:t:p arg; do
				case $arg in
					p)
						DATABASE=postgres
						;;
					t)
						NAMESPACE=$(echo $OPTARG | sed 's/ /-/g')
						;;
					v)
						imageVersion=$OPTARG
						;;
					:)
						echo "[FATAL]Option -$OPTARG requires an arguement."
						exit 1
						;;
					\?)
						echo "[FATAL]Invalid option: -$OPTARG"
						exit 1
						;;
				esac
			done
			if [[ -z $NAMESPACE || -z $imageVersion ]]; then
				echo "[FATAL]Both -v and -t must be set"
				help
				exit 1
			fi
			if ! namespaceExists $NAMESPACE; then
				# export namespace for envsubst to pick up
				KSBX_NS=$NAMESPACE
				export KSBX_NS
				if egrep -q "^$imageVersion," $VERSIONFILE; then
					loadVersions $(grep -e "^$imageVersion," $VERSIONFILE | head -1)
					echo "[INFO]Using Gateway $KSBX_GATE_VERS, Dashboard $KSBX_DASH_VERS, Pump $KSBX_PUMP_VERS"
				else
					echo "[FATAL]Unable to find '$imageVersion' in '$VERSIONFILE'"
					exit 1
				fi
				createNamespace
				if [[ $DATABASE == 'mongo' ]]; then
					echo "[INFO]Starting redis and mongo in the control plane"
					applyYAML mongo.yaml redis-control.yaml # grpc-plugin.yaml
					waitDeploymentReady control-redis
					waitDeploymentReady mongo-db
				elif [[ $DATABASE == 'postgres' ]]; then
					echo "[INFO]Starting redis and postgres in the control plane"
					applyYAML postgres.yaml redis-control.yaml # grpc-plugin.yaml
					waitDeploymentReady control-redis
					waitDeploymentReady postgres-db
				fi
				echo "[INFO]Starting dashboard, pump and gateway"
				# setup configmaps first
				applyYAML tyk-gateway-configmap-control.yaml
				if [[ $DATABASE == 'mongo' ]]; then
					applyYAML tyk-dashboard-configmap-mongo.yaml tyk-pump-configmap-mongo.yaml
				elif [[ $DATABASE == 'postgres' ]]; then
					applyYAML tyk-dashboard-configmap-postgres.yaml tyk-pump-configmap-postgres.yaml
				fi
				# create dashboard, control gateway and pump deployments
				applyYAML tyk-dashboard.yaml tyk-gateway-control.yaml tyk-pump.yaml
				# create dashboard and control gateway services
				applyYAML tyk-dashboard-svc.yaml tyk-gateway-svc-control.yaml
				waitDeploymentReady tyk-dashboard
				waitDeploymentReady control-gateway
				licenseDashboard
				addDashboardUser
				publishAPIs $SCRIPTDIR/APIs/*.json
				listPods
				reportSanboxInfo 
			else
				echo "[FATAL]Namespace '$NAMESPACE' already exists"
				exit 1
			fi
			;;
		delete | rm | del)
			shift
			if [[ $# -lt 1 ]]; then
				echo "[FATAL]Must provide namespace"
				exit 1
			fi
			kubectl delete namespace $*
			tidyPVCs
			;;
		help)
			help
			exit 0
			;;
		list)
			kubectl get namespaces --selector=$NAMESPACE_SELECTOR
			;;
		log*)
			shift
      if [[ $# -lt 1 ]]; then
        echo "[FATAL]Must provide namespace"
        exit 1
      fi
      NAMESPACE=$1
			shift
			showLogs $1
			;;
		pods)
			shift
			if [[ $# -lt 1 ]]; then
				echo "[FATAL]Must provide namespace"
				exit 1
			fi
			NAMESPACE=$1
			listPods
			;;
		publish)
			shift
			if [[ $# -lt 1 ]]; then
        echo "[FATAL]Must provide namespace"
        exit 1
      fi
			NAMESPACE=$1
			shift
			publishAPIs "$@"
			;;
		info)
			shift
			if [[ $# -lt 1 ]]; then
				echo "[FATAL]Must provide namespace"
				exit 1
			fi
			for NAMESPACE in $*; do
				if namespaceExists $NAMESPACE; then
					# set DATABASE for this namespace
					getDatabaseType
					echo "[INFO]$NAMESPACE"
					showTykVersions
					listPods
					reportSanboxInfo
				else
					echo "[WARN]Namespace '$NAMESPACE' not found"
				fi
			done
			;;
		shell)
			shift
			if [[ $# -lt 1 ]]; then
				echo "[FATAL]Must provide namespace"
				exit 1
			fi
			NAMESPACE=$1
			shift
			runShell $*
			;;
		*)
			echo "[FATAL]$1 not implemented"
			;;
	esac
else
	help
fi
