#!/usr/bin/ksh -u

# bring up minikube and deploy a basic install

SCRIPTNAME=$0
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:$PATH
SCRIPTDIR=$(
  cd "$(dirname $SCRIPTNAME)"
  echo $PWD
)
YAMLDIR="$SCRIPTDIR/YAML"
NAMESPACE_SELECTOR="purpose=support"

# load env variables
ENVFILE=~/.tyk-sandbox
. $ENVFILE

# start minikube if it's not already running
function startMinikube {
	if ! minikube status > /dev/null 2>&1 ;then
		echo "[INFO]Starting minikube"
		minikube start --driver docker
	fi
	minikubeIP=$(minikube ip)
}

function getPodName {
	kubectl get pods --no-headers=true -n $NAMESPACE | awk '/^'$1'/ {print $1}'
}

function help {
	typeset name
	name=$(basename $SCRIPTNAME)
	echo "[USAGE]:"
	echo "$name create <intance tag>"
	echo "      Create a tyk instance the name space given as a tag"
	echo "$name delete <instance tag>"
	echo "      Delete the namespace given as a tag and all resources in it"
	echo "$name list"
	echo "      List all namespaces"
	echo "$name info <instance tag>"
	echo "      Print info on the particular instance"
}

# wait for a pod to start
function waitPodReady {
	typeset podname
	podname=$(getPodName $1)
	echo -n "[INFO]Waiting for $NAMESPACE:$podname to start"
	while [[ $( kubectl get pods --no-headers=true -n $NAMESPACE "$podname" | awk -F '[ /]+' '{print $2}' ) -ne 1 ]]; do
		sleep 5
		echo -n .
	done
	echo
}

function getDashboardPort {
	kubectl get svc -n $NAMESPACE tyk-dashboard --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getGatewayPort {
	kubectl get svc -n $NAMESPACE tyk-gateway --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function reportSanboxInfo {
	echo "$NAMESPACE.dashboard: http://$minikubeIP:$(getDashboardPort)/"
	echo "$NAMESPACE.gateway:   http://$minikubeIP:$(getGatewayPort)/"
}

function createNamespace {
	if ! kubectl get namespaces | grep -wq $NAMESPACE; then
		kubectl create ns $NAMESPACE
		kubectl label ns $NAMESPACE $NAMESPACE_SELECTOR
		echo "[INFO]Created namespace '$NAMESPACE'"
	fi
}

function applyYAML {
	typeset YAML
	typeset YAMLfile
	YAML=""
	for YAMLfile in $*; do
		YAML="$YAML -f $YAMLDIR/$YAMLfile"
	done
	kubectl apply -n $NAMESPACE $YAML
}

function licenseDashboard {
	if [[ -n $SBX_LICENSE ]]; then
		curl -k -s -d "license=$SBX_LICENSE" http://$minikubeIP:$(getDashboardPort)/license
	fi
}

function addDashboardUser {
	if [[ -n $SBX_USER && -n $SBX_PASSWORD ]]; then
		SBX_CLEAR_PASSWORD=$(echo $SBX_PASSWORD | base64 -d)
		# this bootstrap method is reliable for versions 2.9.x - 3.2.x (won't work on 2.8.x or earlier)
		curl -s -d "email_address=$SBX_USER&first_name=Tyk&last_name=Admin&password=$SBX_CLEAR_PASSWORD&confirm_password=$SBX_CLEAR_PASSWORD" http://$minikubeIP:$(getDashboardPort)/bootstrap
	fi
}

function listPods {
	kubectl get pods -n $NAMESPACE
}

# Process commands and take actions
# make sure minikube is running and populate minikubeIP, the minikubeIP address it uses

if [[ $# -gt 0 ]]; then
	startMinikube
	case $1 in 
		create)
			shift
			if [[ $# -lt 1 ]]; then
				echo "[FATAL]Must provide namespace"
				exit 1
			fi
			NAMESPACE=$1
			createNamespace
			echo "[INFO]Starting redis and mongo"
			applyYAML mongo.yaml redis.yaml
			waitPodReady redis
			waitPodReady mongo
			sleep 5
			echo "[INFO]Starting dashboard, pump and gateway"
			applyYAML tyk-dashboard.yaml tyk-gateway.yaml tyk-dashboard-svc.yaml tyk-gateway-svc.yaml tyk-pump.yaml
			waitPodReady tyk-dashboard
			reportSanboxInfo 
			licenseDashboard
			addDashboardUser
			;;
		delete | rm | del)
			shift
			if [[ $# -lt 1 ]]; then
				echo "[FATAL]Must provide namespace"
				exit 1
			fi
			kubectl delete namespace $*
			;;
		list)
			kubectl get namespaces --selector=$NAMESPACE_SELECTOR
			;;
		pods)
			shift
			NAMESPACE=$1
			listPods
			;;
		info)
			shift
			NAMESPACE=$1
			listPods
			reportSanboxInfo
			;;
		*)
			echo "[FATAL]$1 not implemented"
			;;
	esac
else
	help
fi
